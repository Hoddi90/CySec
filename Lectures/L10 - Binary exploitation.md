---
tags:
  - Category/Lecture-Notes
aliases:
  - Lecture-Note
---

Binary exploiting is exploiting binary compilations and memory in your code.


- **In what ways does a "memory-safe" language like Rust solve the problem of Buffer Overflow attacks?** Rust prevents programs from writing more data than the buffer can hold by enforcing strict bounds checking on arrays and other collections.
- **Why are programs written in Rust still not 100% safe?** Rust has an _unsafe_ mode available for us that doesn’t enforce memory safety guidelines. The unsafe mode allows the programmer to overwrite the compiler if the programmer’s code is rejected. If Rust didn’t allow unsafe operations programmer’s would be unable to do certain tasks in low-level systems programming. There are 5 actions in unsafe Rust that you can’t do in safe Rust which are referred to as unsafe superpowers. They include the ability to:

1. Dereference a raw pointer
2. Call an unsafe function or method
3. Access or modify a mutable static variable
4. Implement an unsafe trait
5. Access files of union S

 Everything that can go wrong in Rust (buffer overflows, use-after-free, sql injections, side-channel attacks, etc.) has to go through one or more of these 5 gates.



What negative impact on Security can a push for rewriting software in memory-safe languages have?

1.       Rewriting old code to be memory-safe is difficult and will take a lot of time. It might also fail in that it accidentally creates new bugs unrelated to the memory safety. Essentially the principle of “if it works, don’t fix it”.

2.       (Please add more here)


 ###### Research **Use-After-Free (UAF) and Double Free vulnerabilities**. What are these vulnerabilities, how can they be exploited and what are mitigation means?
 
 1. **Use-After-Free (UAF)** vulnerability is a dynamic memory (heap) allocation vulnerability. It uses a pointer to constantly check which sections of the heap are available and unavailable. However, if a data set in dynamic memory is deleted or moved to another block and the pointer is not cleared (set to null), the pointer dangles.
- An attacker could insert data in the memory where that pointer is, thus enabling code substitution. The potential consequences of this are data corruption, program crashes and arbitrary code execution. 
- It can be mitigated by setting pointers to NULL after dynamic memory is deleted or moved to another block, avoiding manual memory management where possible e.g. via smart pointers in C++, and using memory-safe languages e.g. Rust or Java. 

2. **Double Free** is a memory management vulnerability that happens when a program releases the same memory block twice using the free() or delete function. Calling free() with the same argument more than once can result in corrupted memory management data structures.
- Using free() once will make an associated block available for other allocations within the program. Using free() again on the same memory block could corrupt the allocated memory or the internal structures used by the memory management system.
- It introduces vulnerabilities that enable attackers to overwrite function pointers, return addresses and other remote code executions. It can be mitigated by making sure that the free() function is never called more than once, setting the pointers to NULL after the dynamic memory is deleted or moved to another block and having in-built checks  (glibc from the GNU C library) to catch when free() is called more often than once.
# Lecture Title

**Date:** {{25.11.2025}}
**Created:** {{07.12.2025}}

---

## Key Concepts & Takeaways

- [Placeholder]
- [Placeholder]
- [Placeholder]

---

## Connections to Earlier Material

- [New topic] → relates to [old topic] because…
- [ ]

---

## Questions for Discussion / Research

- [[Pwntools]]
- [[ROP(Gadget)]]
- [[Ret2Libc]]
- [Placeholder]

---

## Diagrams / Examples / Code

### Diagram / Example
- [Short description]

```python
[ASCII sketch or notes about diagram]
# paste code example
Code Snippet
lang
Copy code
# paste code example
```

